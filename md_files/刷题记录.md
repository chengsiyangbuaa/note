## 栈与队列
1. getMin的栈
   1. 用两个栈。第一个栈是原始栈，存最原始的数据。第二个栈负责记录目前栈中最小值。
      1. 压入：第一个栈每压入一个元素，这个元素与第二个栈的栈顶元素对比，如果大于等于栈顶元素，则第二个栈压入一个栈顶元素。如果这个元素比第二个栈的栈顶元素小，则将此元素压入第二个栈。
      2. 弹出：第一个栈每弹出一个元素，第二个栈也跟着弹出一个元素。
      3. getMin：第二个栈的栈顶元素就是第一个栈的min。
2. 两个栈组成队列
   1. 用两个栈。
      1. 压入：队列每压入一个元素，在第一个栈中压入一个元素。
      2. 弹出：如果第二个栈中非空，则弹出第二个栈的元素。如果第二个栈为空，则将第一个栈的元素全部弹出并且按顺序压入第二个栈。然后弹出第二个栈的元素。此时第一个栈为空。
3. 逆序一个栈，使用递归的方法
   1. 设计两个递归函数
      1. 第一个递归函数：获取并移除最后的一个元素
      2. 第二个递归函数：利用第一个递归函数，逆序栈。
4. 用一个栈实现另一个栈的排序—————从顶到底按从小到大排序。只允许申请一个栈
   1. 第一个栈是原始的栈。第二个栈是辅助栈。
   2. 思路：在第二个栈中获得顶到底从大到小的顺序。即可反相关操作在第一个栈中从小到大。即要维护第二个栈从栈顶到栈底从大到小的顺序。
   3. 弹出第一个栈的元素。
      1. 如果第二个栈为空，则将此元素压入第二个栈。继续3.
      2. 入如果第二个栈不为空，则比较第二个栈的栈顶元素和此元素的大小。
         1. 如果栈顶元素比此元素小，则压入此元素。
         2. 如果栈顶元素大于等于此元素，则弹出第二个栈的元素，并压入第一个栈。
         3. 继续比较此元素和当前第二个栈的栈顶元素。
            1. 如果此元素比栈顶元素大，则压入此元素到第二个栈。继续3
            2. 如果此元素小于等于栈顶元素，则继续3.2.2
5. 生成窗口最大值数组
   1. 暴力：O(N*w)
   2. 使用队列：
      1. 特性1：队列的从尾到头的元素，由新到旧（维护窗口，头部元素是最老元素，不在窗口内需要弹出）
      2. 特性2：队列的从尾到头的元素，由小到大（保证队首元素是最大元素）
      3. 特性1+特性2 = 窗口内的最大元素是队列的头部元素。
      4. 猜想，如果让队列从尾到头是从大到小，能否做此题。 
         1. 如果队列从尾到头是从大到小，那么想要找最大的元素要在队尾找。
         2. 由于我们想维护一个从尾到头是由新到旧的顺序，所以需要从尾部插入，并且只能放在尾部
         3. 如果此元素比尾部的元素小，则：
            1. 不进入队列，可以
               1. 保持队列的特性1：从尾到头的元素，由新到旧
               2. 失去相应的信息，此元素的值永远被丢弃，后续窗口中丢失此信息。
            2. 进入队列找到相应位置，则
               1. 可以保证队列的特性2：队列的从尾到头的元素，由大到小（保证队尾元素是最大元素）
               2. 失去特性1：无法保证队列的进入顺序，无法维护窗口。
      5. 总结：队列的特性：先进先出。可以保持元素的进入的先后顺序。可以以此维护窗口。通过对队列的修剪（不改变队列的顺序），可以让队列获得其他特性：(大小)有序队列。
6. 单调栈结构
   1. 核心问题，找出数组中每个元素的下一个（上一个）大于（小于）它的值的index。
   2. 应用：直方图的面积，最大矩阵面积，雨水。
7. 